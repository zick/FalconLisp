load regex

kLPar = '('
kRPar = ')'
kQuote = "'"

// Wrapper of a dictionary. This class is necessary for address comparison.
class L(tag, dict)
  tag_ = tag
  dict_ = dict
  function __getIndex(index)
    return self.dict_[index]
  end
  function __setIndex(index, value)
    self.dict_[index] = value
  end
  function tag()
    return self.tag_
  end
end

kNil = L('nil', ['data' => 'nil'])

function safeCar(obj)
  if obj.tag() == 'cons': return obj['car']
  return kNil
end

function safeCdr(obj)
  if obj.tag() == 'cons': return obj['cdr']
  return kNil
end

function makeError(str): return L('error', ['data' => str])

sym_table = [ => ]
function makeSym(str)
  global sym_table
  if str == 'nil': return kNil
  if str notin sym_table: sym_table[str] = L('sym', ['data' => str])
  return sym_table[str]
end

function makeNum(num): return L('num', ['data' => num])

function makeCons(a, d): return L('cons', ['car' => a, 'cdr' => d])

function makeSubr(fn): return L('fn', ['data' => fn])

function makeExpr(args, env)
  return L('expr', ['args' => safeCar(args),
                    'body' => safeCdr(args),
                    'env' => env])
end

function nreverse(lst)
  ret = kNil
  while lst.tag() == 'cons'
    tmp = lst['cdr']
    lst['cdr'] = ret
    ret = lst
    lst = tmp
  end
  return ret
end

function isDelimiter(c)
  return c == kLPar or c == kRPar or c == kQuote or Regex('\s+').match(c)
end

function skipSpaces(str): return Regex('^\s+').replace(str, '')

function makeNumOrSym(str)
  if Regex('^[+-]?\d+$').match(str)
    return makeNum(int(str))
  end
  return makeSym(str)
end

function readAtom(str)
  next = ''
  i = 0
  while (i < len(str))
    if isDelimiter(str[i])
      next = str[i:]
      str = str[:i]
      break
    end
    i++
  end
  return [makeNumOrSym(str), next]
end

function read(str)
  str = skipSpaces(str)
  if str == ''
    return [makeError('empty input'), '']
  elif str[0] == kRPar
    return [makeError('invalid syntax: ' + str), '']
  elif str[0] == kLPar
    return readList(str[1:])
  elif str[0] == kQuote
    [elm, next] = read(str[1:])
    return [makeCons(makeSym('quote'), makeCons(elm, kNil)), next]
  end
  return readAtom(str)
end

function readList(str)
  ret = kNil
  while true
    str = skipSpaces(str)
    if str == ''
      return [makeError('unfinished parenthesis'), '']
    elif str[0] == kRPar
      break
    end
    [elm, next] = read(str)
    if elm.tag() == 'error': return [elm, '']
    ret = makeCons(elm, ret)
    str = next
  end
  return [nreverse(ret), str[1:]]
end

function printObj(obj)
  if obj.tag() == 'num' or obj.tag() == 'sym' or obj.tag() == 'nil'
    return obj['data'].toString()
  elif obj.tag() == 'error'
    return '<error: ' + obj['data'] + '>'
  elif obj.tag() == 'cons'
    return printList(obj)
  elif obj.tag() == 'subr' or obj.tag() == 'expr'
    return '<' + obj.tag() + '>'
  end
  return '<unknown>'
end

function printList(obj)
  ret = ''
  first = true
  while obj.tag() == 'cons'
    if first
      first = false
    else
      ret += ' '
    end
    ret += printObj(obj['car'])
    obj = obj['cdr']
  end
  if obj.tag() == 'nil': return '(' + ret + ')'
  return '(' + ret + ' . ' + printObj(obj) +')'
end

print('> ')
while (line = stdIn().grabLine())
  printl(printObj(read(line)[0]))
  print('> ')
end
